\documentclass[]{report}


% Title Page
\title{SCUT 2019 Fall Software Engineering Review}
\author{qixuan}


\begin{document}
\maketitle

\begin{abstract}
	Chapter 1: Overview\\
	Chapter 2: Software Processes\\
	Chapter 3: UML modeling\\
	Chapter 4: Ruby\\
	Chapter 5: PetriNet\\
	Chapter 6: Requirement Engineering\\
	Chapter 7: Formal Specification\\
	Chapter 8: Architectural Design\\
	Chapter 9: Rails\_MVC\\
	Chapter 10: Design Pattern\\
	Chapter 11: Rails\_Test\\
	Chapter 12: Software Testing\\
	Chapter 13: Basic Path\\
\end{abstract}

\section*{Chapter 1: Overview}
\textbf{Software = Program + Data + Document}\\
\textbf{Software crisis(1968 at a conference)}

new computer hardware

larger and more complex software

software cost more than predicted

New techniques and methods needed to control the large software systems\\
\textbf{Software Engineering - born on a conference in German, 1968.}

A \textbf{Engineering Principle} to handle Software\\
\textbf{Three basic elements of SE: }

$\bullet$\textbf{Method: }refers to a formal procedure; a formal “recipe” for accomplishing a goal that is typically independent of the tools used

$\bullet$\textbf{Tool: }an instrument or automated system for accomplishing something in a better way

$\bullet$\textbf{Procedure: }a combination of tools and techniques to produce a product\\
\textbf{Methods of SE: }

$\bullet$\textbf{UML and other models}

$\bullet$\textbf{Design Pattern}

$\bullet$\textbf{Formal method}

$\bullet$\textbf{Agile Development}\\
\textbf{Procedure of SE: }

$\bullet$\textbf{Analysis(Requirement specification)}

$\bullet$\textbf{Design}

$\bullet$\textbf{Implementation}

$\bullet$\textbf{Testing}\\
\textbf{Environment and Tools: }

$\bullet$\textbf{Ruby}

$\bullet$\textbf{Rails}\\
\textbf{Other topics: }

$\bullet$\textbf{Declarative Programming: Prolog}

$\bullet$\textbf{Distributed Architecture: CORBA}\\

\textbf{Analysis:} decompose a large problem into smaller, understandable pieces
(abstraction is the key)
\textbf{Synthesis:} build (compose) a software from smaller building blocks
(composition is challenging)

\textbf{Changes in SE:} Desktop Computing, Object Technology, Problems with waterfall, Time to market, Networking, User interfaces, Shifts in economics.

\textbf{Software Lifecycle}\\

\textbf{Software Process}

\textbf{software process model} is a simplified description of a software process, include activities of software process, software products and the role of people involved.

\textbf{To model software development: }Waterfall approach,
Iterative development,
Component-based software 
engineering.\\

\textbf{Development process models}

Although software engineering involves all three processes, in this chapter we discuss only the development process, which is shown outside the cycle . The development process in the software lifecycle involves four phases: \textbf{analysis (requirement specificiation), design, implementation and testing}. There are several models for the development process. We discuss the two most common here: the \textbf{waterfall model} and the \textbf{iterative model}.\\

\textbf{The waterfall model}

In this model, the development process flows in only one direction. This means that a phase cannot be started until the previous phase is completed

$\bullet$\textbf{Analysis(Requirement specification)}

$\bullet$\textbf{Design}

$\bullet$\textbf{Implementation}

$\bullet$\textbf{Testing}\\

\textbf{The iterative model}

In the iterative model, software is developed in a series of steps.

Each increment is a entire waterfall process.\\

\textbf{Software Development Steps: }

Requirement Analysis and Definition: procedure-oriented or object-oriented, UML, output a specification document.

System Design: All part of system defined, Structure charts, Modularity(\textbf{Coupling} between modules in a software system
must be minimized and \textbf{Cohesion} within modules in a software system
must be maximized).

Program Design

Program Implementation: Choice of language, Software quality.

Unit Testing: glass-box(white box), black box(exhaustive, random, boundary-value), \textbf{basis path testing} is a method in which each statement in the software is executed at least once.

Integration Testing

System Testing

System Delivery

Maintenance\\

\textbf{Documentation}

For software to be used properly and maintained efficiently, documentation is needed. Usually, three separate sets of documentation are prepared for software:  \textbf{user documentation, system documentation and   technical documentation}.

\textbf{Documentation is an ongoing process.}\\


\end{document}          
